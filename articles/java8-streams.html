<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>JEXP | Untitled</title>
    <meta http-equiv='Content-Style-Type' content='text/css' />
  <link rel='stylesheet' href='/css/jexp.css' type='text/css' />
  <link rel="openid.server" href="http://jexp.de/id" />
<!--HeaderText--><style type='text/css'><!--
  div.wikibody { line-height: 1.6em; font-size:1.4em; }
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
   
  table.tabtable { border-collapse: collapse; }
  table.tabtable td { border:1px solid #cccccc; }

div.sourceblock {
	padding: 0.5em;
	border: 1px solid #808080;
	background-color: #F1F0ED; }
div.sourceblock div {
	font-family: monospace;
	font-size: small;
	line-height: 1; }
div.sourceblock div.head, div.sourceblock div.foot {
	font: italic medium serif;
	padding: 0.5em;
}
div.codeblock {
	padding: 0.5em;
	border: 1px solid #808080;
	background-color: #F1F0ED; }
div.codeblock pre {
	font-family: monospace;
	font-size: small;
	line-height: 1; }.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
    <meta name='robots' content='index,follow' />


</head>
<body>
<!--PageHeaderFmt-->
  <div id='wikihead'><a href='/'><img src='/img/jexp.gif'
    alt='JEXP' border='0' align="center" /></a>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    JEXP</div>
<!--/PageHeaderFmt-->

<div id="wikileft">
   <ul>
	<li><a class='urllink' href='http://www.jexp.de/blog'>BLOG</a></li>
	<li><a class='urllink' href='http://github.com/jexp'>GitHub</a></li>
	<li><a class='urllink' href='/conferences.html'>Conferences</a></li>
	<li><a class='urllink' href='/articles.html'>Articles</a></li>
	<li><a class='urllink' href='/books.html'>Books</a></li>
	<li><a class='urllink' href='/projects.html'>Projects</a></li>
	<li><a class='urllink' href='/bio.html'>Bio</a></li>
<!--
<li><a class='wikilink' href='/Main.Projects'>Projects</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Info.Biografie'>Bio</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Business.Referenzen'>References</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Info.Links'>Links</a>
</li><li><a class='urllink' href='http://www.librarything.com/catalog/mesirii' rel='nofollow'>Books</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Info.BetterDevelopment'>BetterDevelopment</a>
</li><li><a class='wikilink' href='/Info.Konferenzen'>Conferences</a>
</li><li><a class='wikilink' href='/Info.Demotivators'>Demotivators</a>
</li><li><a class='wikilink' href='/Info.Quotes'>Quotes</a>
</li><li><a class='wikilink' href='/Main.Reviews'>Reviews</a>
<ul><li><a class='wikilink' href='/DslBook.DslBook'>DslBook</a>
</li></ul></li><li><a class='wikilink' href='/Main.Java'>Java</a>
<ul><li><a class='urllink' href='http://jequel.de' rel='nofollow'>Jequel</a>
</li><li><a class='wikilink' href='/BricksAndMortar.BricksAndMortar'>BricksAndMortar</a>
</li><li><a class='wikilink' href='/Java.Projects'>Look@Projects</a>
</li><li><a class='wikilink' href='/Java.Spring'>Spring</a>
</li><li><a class='wikilink' href='/Java.Code'>Code</a>
</li></ul><p class='vspace'></p></li><li><a class='wikilink' href='/Site.Impressum'>Impressum</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Site.Internal'>Internal</a>
</li>
-->

</ul>

</div>

<div id="wikibody">

<div class="paragraph">
<p>Java-8 - Streams - Funktionale Handhabung von Containern</p>
</div>
<div class="paragraph">
<p>Ich hätte es kaum noch für möglich gehalten, dass in Java noch Dinge eingeführt werden, die richtig Spass machen und auch den Abstand anderer Programmiersprachen, wie z.B. Scala zumindest etwas verringern.
Die Rede ist hier nicht vor allem von Lambda-Functions (einfache Closures), sondern vor allem von Streams, der funktionalen Erweiterung der Collections-API. Vieles von dem was heute hier diskutiert wird, gibt es in der einen oder anderen Form schon in existierenden funktionalen oder Containerbibliotheken für Java [libs], aber mit den dargestellten Spracherweiterungen erhält es noch einmal einen ganz anderen Stellewert.</p>
</div>
<div class="paragraph">
<p>Streams erlauben es, die kontinuierliche Verarbeitung von Daten in Kollektionen (Iterable, Collection, List, Set, Map usw.) anders als mit der klassischen und bekannten "for"-Schleife mittels Aufrufen (Callbacks) in eigenen Code zu steuern und durchzuführen. Das ist aus funktionalen Sprachen zwar schon lange bekannt (mindestens seit den 60ern) aber in Java eine Novität.</p>
</div>
<div class="paragraph">
<p>Wie sieht so etwas aus? Hier das klassische Hello-World Beispiel für diese Art von Code.</p>
</div>
<div class="paragraph">
<p>Arrays.asList(7,6,5,4,3,2,1).stream().map(x &#8594; x * x).filter(x &#8594; x &gt;= 4).skip(1).limit(4).sorted(Integer::compare).groupBy(x&#8594; x%2).values().forEach(System.out::println);</p>
</div>
<div class="paragraph">
<p>Ergibt nach Quadrierung, Filterung, Paginierung, Sortierung, Gruppierung die folgende Ausgabe:</p>
</div>
<div class="paragraph">
<p>VariableStreamBuilder[[9, 25]]
VariableStreamBuilder[[16, 36]]</p>
</div>
<div class="paragraph">
<p>Ich mag mir gar nicht vorstellen wieviel Zeilen Java-Code das normalerweiser erfordert hätte. Neben der besseren Lesbarkeit bietet der funktionale Ansatz eine Menge weiterer Vorteile.
Neben der Diskussion der Vorteile und potentieller Nutzung dieser API möchte ich in dieser Kolumne auch auf die Implementierung der Streams API eingehen.</p>
</div>
<div class="paragraph">
<p>Wie so oft bauen neue Features einer Sprache auf vorhergehenden oder einhergehenden Änderungen auf (Ähnlichkeiten zum Design von LINQ in .net sind sicher nicht ganz zufällig). Die Streams in Java 8
benötigen mindestens zwei Schultern auf denen sie stehen können. Zum einen sind das Lambda-Funktionen (TODO Nomenklatur) und zum anderen Erweiterungs-Methoden (Extension-Methods).</p>
</div>
<div class="paragraph">
<p>Lambda-Funktionen</p>
</div>
<div class="paragraph">
<p>Sie gibt es eigentlich schon seit Anbeginn der Programmiersprache Java. Die Lambda Funktionen in Java 8 sind eigentlich "nur" die syntaktische Vereinfachung der Nutzung von Interfaces mit einer einzigen Methode, sogenannte Single Abstract Method (SAM) interfaces. Sie sind aus vielen Bereichen von Java bekannt, seien es Runnable.run(), Callable&lt;V&gt;.call(), Comparator&lt;T&gt;.compare(T t1,T t2), FilenameFilter usw. Sie werden und wurden eingesetzt um einen ganz bestimmten Aspekt einer Berechnung oder Aktion zu kapseln, ggf. einer API zu genügen (z.B. Threading) oder wiederverwendbar zu machen.  Seit Java 8 können sie mit der Annotation @FunctionalInterface explizit gemacht werden. So annotierte Interfaces würden nicht kompilieren wenn sie nicht genau eine "abstrakte" Methode enthielten.</p>
</div>
<div class="paragraph">
<p>Seit Java 1.1 wurden sie dynamisch oft in der Form von inneren Klassen, spezieller anonymen inneren Klassen genutzt.</p>
</div>
<div class="paragraph">
<p>Es gibt einige Aspekte von Lambdas die wirklich interessant sind. Zum einen kann eine Lambda-Funktion die Rolle eines deklarierten Interfaces (SAM) übernehmen solange sie in der Signatur mit der genutzten Interface-Methode übereinstimmt, d.h. Anzahl und Typen der Parameter (inklusive Konvertierung) und Typ der Rückgabewerte sowie deklarierter Exceptions. (??) Das heisst, diesselbe Lambdafunktion kann folgende zwei Interfaces erfüllen. Der konkrete Typ des in der API deklarierten Interfaces oder die konkrete Methode sind egal.</p>
</div>
<div class="paragraph">
<p>interface Predicate&lt;T&gt; { boolean match(T value); }
interface IntFilter { boolean filter(int number); }</p>
</div>
<div class="paragraph">
<p>Für beide kann ich die Lambda Funktion " x &#8594;  x &lt; 3 " einsetzen. Siehe folgendes Beispiel:</p>
</div>
<div class="paragraph">
<p>static class Applicator {
    &lt;T&gt; void applyPredicate(Predicate&lt;T&gt; pred) {}
    void applyFilter(IntFilter filter) {}
}</p>
</div>
<div class="paragraph">
<p>Applicator app = new Applicator()</p>
</div>
<div class="paragraph">
<p>app.applyFilter(new IntFilter() { boolean filter(int number) { return number &lt; 3;}});
app.applyFilter(x &#8594; x &lt; 3);</p>
</div>
<div class="paragraph">
<p>app.applyFilter((Integer x) &#8594; x &lt; 3);</p>
</div>
<div class="paragraph">
<p>app.applyPredicate(new Predicate&lt;Integer&gt;() { boolean match(Integer value) { return value &lt; 3;}});
app.applyPredicate((Integer x) &#8594; x &lt; 3);</p>
</div>
<div class="paragraph">
<p>final Predicate&lt;Integer&gt; lessThanThree = (Integer x) &#8594; x &lt; 3;
app.applyPredicate(lessThanThree);</p>
</div>
<div class="paragraph">
<p>Wie am Beispiel gesehen sind Lambdas nicht auf offizielle API des JDKs beschränkt ich kann an jeder Stelle im Code an der ich SAMs als Callback-Parameter deklariere entsprechende Lambdas nutzen. Somit können auch viele Aspekte aus typischen Business Anwendungen viel kompakter und klarer ausfallen, die Lesbarkeit erhöht sich deutlich, da der unnötige Rahmen der Klassendeklaration komplett entfällt.</p>
</div>
<div class="paragraph">
<p>Die genutzten Ausdrücke sollten dann aber auch sprechend genug sein, mittels geeigneter Variablennamen kann man eine Menge erreichen.
Indem man die Lambda in eine benannte Variable auslagert die dann dem entsprechenden Ziel-Interface zugewiesen wird, erhält man verständliche, wiederverwendbar Code-Blöcke.</p>
</div>
<div class="paragraph">
<p>Interessanterweise schlägt meine IDE IntelliJ IDEA für die beiden Aufrufe mittels anonymer innerer Klasse schon die Alternative Nutzung von Lambdas vor.</p>
</div>
<div class="paragraph">
<p>Für Awendungsfälle wie das gezeigte Bespiel wurden zusammen mit dem Lambdas im JDK eine Sammlung von SAMs in java.util.function.* bereitgestellt, die typische Aufgaben und Ausdrücke die mittels einer einzigen Funktion ausgeführt werden können abbilden. Dazu gehören, Quellen (()&#8594;T), Blöcke (T&#8594;void), Prädikate (T&#8594;boolean), unäre (T&#8594;T) und binäre Funktionen (T&amp;T&#8594;T), Reduktions-Operatoren (A&amp;T&#8594;A), jeweils auch für primitive Typen (int, long, double). Die meisten dieser Interfaces werden auch in der Streams-API wieder verwendet, zusammen mit einigen spezialisierten Varianten.</p>
</div>
<div class="paragraph">
<p>Lambdas gibt es in verschiedenen Formen, je nach Signatur der ersetzten Methoden</p>
</div>
<div class="paragraph">
<p>Beispiele von Lambdas:</p>
</div>
<div class="paragraph">
<p>()    &#8594; expr				Lambda ohne Parameter, nur Aktion mit Seiteneffekt
 { }						Block nur Aktion mit Seiteneffekt
 x    &#8594; x					Lambda mit einem Parameter
(Typ x) &#8594; x				Lambda mit Parameter und Typ
(x,y) &#8594; x + y				Lambda mit mehreren Parametern
 x    &#8594; return x+1			Lambda mit vorzeitigem Return
 Integer::compare			statisches Methoden-Literal
 System.out::println		Instanzmethoden-Literal</p>
</div>
<div class="paragraph">
<p>Ein interessantes Detail stellt die Verwendung von Methoden-Literalen als Lambdas dar. So können statisch oder Instanzmethoden einfach als Methodenliteral referenziert und somit die einfache Delegation an diese Methode kompakt notiert werden.</p>
</div>
<div class="paragraph">
<p>Auch wenn Lambda&#8217;s machmal als Closures bezeichnet werden, sind sie das nicht wirklich sie "umschliessen" Variablen (auch lokale) die zum Zeitpunkt ihrer Erzeugung schon deklariert sind nur bedingt. Nur Variablen die als "final" gekennzeichnet sind oder als solche betrachtet werden können (einmalige Zuweisungen), können innerhalb einer Lambda-Funktion genutzt werden. Damit gelten diesselben Regeln wie bei anonymen inneren Klassen. So können auch Lambdas ohne Parameter potentiell auf Werte von aussen zugreifen. Das kann wichtig werden, wenn die geforderte API keine Callback-Methoden mit Parametern zulässt.</p>
</div>
<div class="paragraph">
<p>Für die Anwendbarkeit von Prädikaten als Spezifikationen haben Martin Fowler und Eric Evans ein sehr anschauliches Pattern namens "Specification" [Specification] beschrieben, dass m.E. eines der wichtigsten Pattern darstellt.
Wie dort diskutiert haben Spezifikaten eine Reihe von Vorteilen - so Wiederverwendung und Kombinierbarkeit zur leicht nachvollziehbaren Deklaration von Regelwerken oder komplexer Bedingungen über die Abbildung von Entscheidungsbäumen bis zur Quelle für das Erzeugen von Abfrage für verschiedene Backends oder deren Ausführung auf Datencontainern im Speicher.
Wie auch schon dort beschrieben können boolesche Prädikate, d.h. Interfaces oder abstrakte Klassen mit einer definierten Methode die Objekte entgegennimmt und ein boolesches Ergebnis liefert als Prädikate oder Spezifikationen eingesetzt werden. Und dasselbe gilt natürlich auch für Lambda Funktionen die zu einem booleschen Ergebnis evaluieren.</p>
</div>
<div class="paragraph">
<p>Erweiterungs-Methoden:</p>
</div>
<div class="paragraph">
<p>Ein weiter wichtiger Baustein für die Streams-API stellen die Erweiterungsmethoden (oder auch Extension-/Defender-Methods) dar. Diese erlauben es, einem Interface neue Methoden hinzuzufügen und auch gleich deren Implementierung mittels des "default" Schlüsselwortes bereitzustellen. Solange abgeleitete Klassen diese neuen Interface-Methoden nicht selbst implementieren, wird die Standardimplementierung der Methodendeklaration benutzt. Diese kann dann natürlich wieder an andere Objekte oder Klassen (statisch) delegieren. Dieses neue Feature ist viel wichtiger als es zunächst aussieht.</p>
</div>
<div class="paragraph">
<p>Zum einen erlaubt es eine viel bessere API Evolution ohne den Interface Wildwuchs wie z.b. im Eclipse SDK oder der Nutzung von abstrakten Klassen mit Standardimplementierungen von Methoden (die dann durch die Mehrfahrvererbungsregeln die Entwicklung von komplexeren Plugins verhindern). Das schöne ist: das gilt nicht nur für neue API-Interfaces sondern auch besonders für schon lange existierende.</p>
</div>
<div class="paragraph">
<p>So musste z.B: für die massive Erweiterung der Collection-API um Lambdas, interne Iteratoren und Streams keine zweites, inkompatibles Collection 2.0 (oder 3.0) Paket erstellt werden, das inkompatibel zu allem existierenden Code wäre (und damit wahrscheinlich keinen grossen Zuspruch gefunden hätte). Stattdessen konnten Interfaces wie Iterable, Collection usw. einfach mit neuen Methoden sowie einer Standardimplementierung erweitert werden die die notwendigen Anwendungsfälle abdeckt.</p>
</div>
<div class="paragraph">
<p>Hier zwei Beispiele.</p>
</div>
<div class="paragraph">
<p>interface java.util.Map&lt;K,V&gt; {
	void forEach(BiBlock&lt;? super K, ? super V&gt; block) default {
        for (Map.Entry&lt;K, V&gt; entry : entrySet())
            block.apply(entry.getKey(), entry.getValue());
    }
}</p>
</div>
<div class="paragraph">
<p>interface java.util.Collection&lt;E&gt; extends &#8230;&#8203;. Streamable&lt;Stream&lt;E&gt;&gt; &#8230;&#8203; {
	@Override
    Stream&lt;E&gt; stream() default {
        return Streams.stream(this);
    }
}</p>
</div>
<div class="paragraph">
<p>Wobei "Streams.stream()" wie folgt implementiert ist.</p>
</div>
<div class="paragraph">
<p>public static&lt;T&gt; Stream&lt;T&gt; stream(Collection&lt;T&gt; source) {
    return new ValuePipeline&lt;&gt;(new TraversableStreamAccessor&lt;&gt;(source, false, false, source.size()));
}</p>
</div>
<div class="paragraph">
<p>Und das führt uns auch schon tief in die Implementierung der Streams API zu deren Erforschung ich jetzt einladen will.</p>
</div>
<div class="paragraph">
<p>Streams-API</p>
</div>
<div class="paragraph">
<p>Der funktionale Ansatz der Streams API besteht aus einigen interessanten konzeptionellen Bausteinen. Eine der wichtigsten Änderungen ist der Wechsel von einem "externen Iterator" (der klassische java.util.Iterator bzw. java.lang.Iterable) der Nachfolger von java.util.Enumeration die mittels der bekannten "boolean hasNext()" und "T next()" Methoden von aussen angetrieben werden zu einem "intenren Iterator" bei dem die Steuerung der Iteration, Anwendung von Operationen und Konsumierung der Daten dem Container obliegt.</p>
</div>
<div class="paragraph">
<p>Die wenigen Vorteile externer Iteratoren liegen darin, dass sie weitergereicht werden können und die API relativ einfach ist.
Es gibt viel mehr Nachteile der externen Iteratoren:
- zustandsbehaftet
- Steuerung obliegt dem Nutzer nicht dem Container
- nicht intern optimierbar (parallelisierung)
- massive Objekterzeugung (liefert Objekte aus)
- nicht komponierbar (zusammensetzbar) oder verkettbar
-</p>
</div>
<div class="paragraph">
<p>Ein paar potentielle Optimierungen die entweder so schon im JDK durchgeführt werden oder leicht in Zukunft möglich sind (durch den internen Iterator sind die Details gekapselt).
Für die Iteration müssen keine Objekte erzeugt werden (Unterstützung für primitive Typen) oder angebotene Objekte könnten wiederverwendet werden. Die Iteration kann abhängig von der internen Speicherstruktur der Container in Batches erfolgen (z.b. ein Bucket einer Hash-Map auf einmal) und so z.B. Speichermanagement der CPU unterstützen. Die Iteration kann parallelisiert erfolgen (zur Zeit explizit über "parallel()") und somit vorhandene CPU-Resourcen besser ausnutzen. Wie beim Scala "view" können aufgerufene Operationen in eine oder wenige komplexere Operationen kombiniert werden die dann nicht in mehreren Schritten, sondern auf einmal ausgeführt werden können (Z.B filter() und map() oder sorted() und limit() in ein Top-n-Select). Eine andere interessante Option ist, nicht mit der Iteration zu beginnen bevor nicht das erste Element konsumiert wird und dann auch weiterhin nur jedes konsumierte Element (oder Batch) durch den Strom (Stream) zu saugen (lazy evaluation).</p>
</div>
<div class="paragraph">
<p>Das sind nur einige, wenige Optimierungen, die durch die Kapselung der Stream-API ermöglicht werden.</p>
</div>
<div class="paragraph">
<p>Wie ist die Stream API jetzt implementiert: Die Basis-Interfaces wie java.util.Collection und java.util.Map erben von Streamable&lt;Stream&lt;E&gt;&gt; welches die Methode "stream()" zur Erzeugung von Streams zur Verfügung stellt.</p>
</div>
<div class="paragraph">
<p>java.util.Collection {
	Stream&lt;E&gt; stream() default { return Streams.stream(this); }
}</p>
</div>
<div class="paragraph">
<p>Diese Methode ist standardmässig im Interface implementiert, hat aber spezielle Implementierungen in Subklassen, z.B. in ArrayList&lt;E&gt;</p>
</div>
<div class="paragraph">
<p>public Stream&lt;E&gt; stream() {
    return Streams.stream((E[]) elementData, 0, size);
}</p>
</div>
<div class="paragraph">
<p>"Streams.stream()" stellt nun wiederum eine "ValuePipeline" Instanz zur Verfügung, die das "Stream" Interface implementiert und einen konkreten "Accessor" für die darunterliegende Datenstruktur (Feld, Collection, Map) kapselt.</p>
</div>
<div class="paragraph">
<p>Der Accessor liefert einige Informationen über die Datenstruktur, wie z.B. Größe (oder eine Größenschätzung), einen Iterator für den "Rest" des Streams, und die Form (Werte oder Schlüssel-Wert-Paare) des Streams.  Eine wichtige Methode stellt "StreamAccessor.into(Sink&lt;T, ?, ?&gt; sink)" dar, wobei eine "Sink" einen Konsumenten (Block&lt;T&gt;) von Elementen darstellt. Dieser Konsument kann wiederverwendbar sein, dann werden mittels "begin" und "end" die Blöcke markiert.</p>
</div>
<div class="paragraph">
<p>Sinks können mit weiteren, folgenden "downstream" Konsumenten verknüpft werden um die Pipeline des Streams zu bilden. Das bringt uns zurück zur ValuePipeline, die eine Implementierung der "AbstractPipeline&lt;I, O&gt;" darstellt, wobei I für Eingabe und O für Ausgabeelement-typen stehen.</p>
</div>
<div class="paragraph">
<p>Pipelines verknüpfen wiederum vorhergehende Pipelines mit einer neuen Operation und formen somit einen Stream (Pipeline) der Länge n+1.</p>
</div>
<div class="paragraph">
<p>z.B.
protected&lt;V&gt; Stream&lt;V&gt; AbstractPipeline.chainValue(IntermediateOp&lt;O,V&gt; op) {
   return new ValuePipeline&lt;&gt;(this, op);
}</p>
</div>
<div class="paragraph">
<p>Die exemplarische Abbildung der Implementierung einer einfachen Operation "filter()" des Stream Interfaces in ValuePipeline sieht wie folgt aus, andere Operationen verhalten sich äquivalent:</p>
</div>
<div class="paragraph">
<p>public Stream&lt;O&gt; ValuePipeline.filter(Predicate&lt;? super O&gt; predicate) {
    return chainValue(new FilterOp&lt;&gt;(predicate));
}</p>
</div>
<div class="paragraph">
<p>Der Callback des Awendungscodes "predicate" wird in einer "FilterOp" Operation geproxied damit die API von "chainValue" bedient wird. Die Implementierung von FilterOp, die selbst zustandlos ist (in Bezug auf den Stream), speichert das Prädikat und wendet es dann bei Bedarf an, wie z.B in "wrapSink", die für einen gegebenen Konsumenten nur Elemente weiterreicht, die der Bedingung des Prädikats auch entsprechen.</p>
</div>
<div class="paragraph">
<p>public Sink&lt;T, ?, ?&gt; wrapSink(final Sink sink) {
    return new Sink.ChainedValue&lt;T&gt;(sink) {
        public void accept(T t) {
            if (predicate.test(t))
                downstream.accept(t);
        }
    };
}</p>
</div>
<div class="paragraph">
<p>In diesem Fall hier ändert sich der Typ der Pipeline nicht da nur eine Filterung vorgenommen wird, bei "map()" ist das anders:</p>
</div>
<div class="paragraph">
<p>public &lt;V&gt; Stream&lt;V&gt; map(Mapper&lt;? super O, ? extends V&gt; mapper) {
    return chainValue(new MapOp&lt;&gt;(mapper));
}
public Sink&lt;T, ?, ?&gt; wrapSink(Sink sink) {
    return new Sink.ChainedValue&lt;T&gt;(sink) {
        public void accept(T t) {
            downstream.accept(mapper.map(t));
        }
    };
}</p>
</div>
<div class="paragraph">
<p>Bei allen Operationen und Verknüpfungen ist zu beachten, das ausser Checks auf Null, Typenkompatibilität und Form des Stromes zu diesem nirgendwo eine Aktivität bezüglich des Streams ausgeführt wird. Dies ist alles nur "Setup", wie bei einer "Rube Goldberg" Maschine [RubeGoldberg] werden nur alle Bestandteile in Position gebracht, um dann bei Inbetriebnahme fleissig vor sich hin zu werkeln.</p>
</div>
<div class="paragraph">
<p>Wie kommt nun der eigentliche Konsument ins Spiel? "forEach()" oder "iterator()" sind eine Operation auf dem Stream interface, um einen Konsumenten an das Ende des Streams anzukoppeln. Hier am Beispiel von "forEach()" gezeigt. Anders als sonst, ist die Operation die an die Pipeline angehängt wird, keine "IntermediateOp" die einen Schritt im Verarbeitungsstrom darstellt, sondern eine finale, terminale Operation. In diesem Fall wird der übergebene "Block" (Callback ohne Rückgabewert, nur mit Seiteneffekt) gekapselt in einer TerminalSink an die "pipeline()" Methode der AbstractPipeline übergeben.</p>
</div>
<div class="paragraph">
<p>public void forEach(Block&lt;? super O&gt; block) {
    pipeline(ForEachOp.make(block));
}</p>
</div>
<div class="paragraph">
<p>public static&lt;T&gt; ForEachOp&lt;T&gt; ForEachOp.make(final Block&lt;? super T&gt; block) {
    return new ForEachOp&lt;&gt;(new TerminalSink&lt;T, Void&gt;() {
        public void accept(T t) {
            block.apply(t);
        }
    }
}</p>
</div>
<div class="paragraph">
<p>public&lt;V&gt; V AbstractPipeline.pipeline(TerminalOp&lt;O, V&gt; terminal) {
    return evaluate(terminal);
}</p>
</div>
<div class="paragraph">
<p>Diese macht dann eine Fallunterscheidung nach paralleler oder sequentieller Ausführung und aggregiert dann in "evaluateSerial" alle zwischenzeitlich angesammelten Operationen und deren Attribute.
Für unendliche Streams, die dank der verzögerten Ausführung (lazy Evaluation) z.B. für die Kalkulation von Reihen genutzt werden können, werden nichtterminierende Berechnungen verhindert.</p>
</div>
<div class="paragraph">
<p>protected&lt;V&gt; V AbstractPipeline.evaluateSerial(TerminalOp&lt;U, V&gt; terminal) {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>IntermediateOp[] ops = new IntermediateOp[depth];
boolean intermediateShortCircuit = false;
AbstractPipeline p = this;
int flags = source.getStreamFlags();
for (int i=depth-1; i &gt;= 0; i--) {
    intermediateShortCircuit |= p.op.isShortCircuit();
    ops[i] = p.op;
    flags = ops[i].getStreamFlags(flags);
    p = p.upstream;
}
boolean infinite = (flags &amp; Stream.FLAG_INFINITE) != 0;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>if (infinite &amp;&amp; !terminal.isShortCircuit()) {
    throw new IllegalStateException("An stream of known infinite size is input to a non-short-circuiting terminal operation");
}</pre>
</div>
</div>
<div class="paragraph">
<p>(I. Pull Traversal) Bestimmte Operationen brechen die Evaluierung des Streams ab, diese werden als "Kurzschluss" oder short-circuit Operationen behandelt. Beispiel dafür sind "limit(), skip(), findFirst(), findAny() oder match()" die alle nur ein fixe Anzahl von Ergebnissen (0..n Elemente oder Wahrheitswert) für die komplette Streamverarbeitung liefern. Sowohl für diese Operatoren als auch die Evaluation eines Streams als Iterator wird durch die Senke der terminalen Operation durchgeführt. Im Endeffekt werden alle restlichen Elemente des Streams als ein Batch-Segment aus der "iterator()" Methode gezogen und in die terminale Senke gespeist. Der Iterator ergibt sich für den ersten Schritt der Pipeline aus dem "iterator()" des Source-Accessors und sonst aus der aktuellen Operation ("op") des aktuellen Pipeline-Schritt angewandt auf den "iterator()" des vorherigen Schritts. Somit ist wie beim Matroschka-Prinzip die orginale Quelle über alle Schritte der Pipeline mit ebensovielen Schichten von Pipeline-Operationen umgeben. In der Illustration ist es in der "iterator()" Kette dargestellt.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  if (intermediateShortCircuit || terminal.isShortCircuit() || iterator != null) {
      // I. Pull traversal
   TerminalSink&lt;T,U&gt; terminalSink = terminal.sink();
   terminalSink.begin(-1); // undefiniert grosser Batch
      Iterator&lt;U&gt; iterator = iterator();
// alle restlichen iterator-elemente werden in die Senke geschoben
   while (iterator.hasNext())
       terminalSink.accept(iterator.next());
   terminalSink.end();
   return terminalSink.getAndClearState();
  }</pre>
</div>
</div>
<div class="paragraph">
<p>(II. Push Traversal) Alternativ werden die Elemente nicht aus einem Iterator gezogen, sondern in eine Kette von Senken bis zur finalen Senke geschoben. Die originale Quelle aus dem Stream-Accessor (source) kann mittels "collection.into(sink)" ihre Elemente einem Konsumenten bereitstellen. In diesem Fall ist es die Kette von Senken bis zur finalen Senke die durch Kapselung der jeweils nachgelagerten Senke durch die zugehörige Operation des Pipeline-Schrittes. (IntermediateOp.wrapSink). Jede Operation implementiert das "wrapSink" individuell für ihre Semantik, wie schon weiter oben erklärt für "FilterOp" und "MapOp". Durch die finale "getAndClearState()"</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    else {
        // II. Push traversal
        TerminalSink&lt;U, V&gt; terminalSink = terminal.sink();
        Sink firstSink = terminalSink;
        for (int i=ops.length-1; i &gt;= 0; i--) {
            firstSink = ops[i].wrapSink(firstSink);
        }
        source.into(firstSink);
        return terminalSink.getAndClearState();
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>TODO TerminalSink.getAndClearState();</p>
</div>
<div class="paragraph">
<p>Parallelisierung von Streams</p>
</div>
<div class="paragraph">
<p>Streams bieten die Möglichkeit zwischen sequentieller und paralleler Abarbeitung (mittels "sequential()" und "parallel()") umzuschalten. Die sequentielle Abarbeitung wurde schon diskutiert. Für die parallele Evaluierung werden Intervalle von zustandslosen Operationen identifiziert. Diese werden dann mittels des Fork-Join Frameworks parallel ausgeführt, terminierend mit der darauf folgenden zustandsbehafteten Operation. Das geschieht für alle aufeinanderfolgenen Intervalle. Die Nutzung von Fork Join zur Parallelisierung wurde schon in der Kolumne zum GPars diskutiert.</p>
</div>
<div class="paragraph">
<p>TODO potentiell in einer separaten Kolumne, Parallelisierung von Streams: ParallelOp, ParallelOpHelper, example ForEachOp, Spliterator, AbstractTask</p>
</div>
<div class="paragraph">
<p>Nach diesem Blick hinter die Kulissen möchte ich wieder einen Schritt zurück treten, mit dem Blick auf das große Ganze. Wie können Streams im täglichen Entwicklerleben helfen, Code einfacher und lesbarer zu machen und auch komplexe Berechnungen in wiederverwendbare Komponenten auszulagern. Da alle Kollektionen in Java 8 Streams anbieten und die Stream-Operationen umfangreiche Aspekte der funktionalen Listenverarbeitung umfassen, können diese in fast allen Lebenslagen angewandt werden und komplexe Berechnungen, einfach abbilden.</p>
</div>
<div class="paragraph">
<p>Und Operationen die es nicht gibt, können durch einfach Nutzung bzw. Kombination existierende Operationen und der einen oder anderen Lambda entwickelt werden. Simples Beispiel: Maximum durch Nutzung von absteigender Sortierung und limit(1) oder besser durch ein reduce mit einem minimalen Startwert im Akkumulator und einem ternären Ausdruck:</p>
</div>
<div class="paragraph">
<p>int max = Arrays.asList(1, 10, 3, 100, 5).stream().reduce(0, (a, x) &#8594; x &gt; a ? x : a);</p>
</div>
<div class="paragraph">
<p>Oder mittels der zweiten Form von Reduce die als Startwert einfach den ersten Wert der Liste benutzt:</p>
</div>
<div class="paragraph">
<p>Optional&lt;Integer&gt; max = Arrays.asList(1, 10, 3, 100, 5).stream().reduce((a, x) &#8594; x &gt; a ? x : a);</p>
</div>
<div class="paragraph">
<p>"Optionals" sind fast eine eigene Kolumne wert, aus funktionalen Sprachen kennt man sie als Maybe-Monaden. Jedenfalls eine interessante Alternative mit nicht-existenten oder Null-Werten umzugehen.</p>
</div>
<div class="paragraph">
<p>In diesem Fall kann der Ausdruck für Max einfach einer Variablen zugewiesen werden:</p>
</div>
<div class="paragraph">
<p>final BinaryOperator&lt;Integer&gt; maxOp = (a, x) &#8594; x &gt; a ? x : a;
final Optional&lt;Integer&gt; max2 = Arrays.asList(1, 10, 3, 100, 5).stream().reduce(maxOp);</p>
</div>
<div class="paragraph">
<p>Man kann natürlich auch die funktionalen Interfaces und Klassen direkt implementieren. Das bietet sich besonders für komplexere Aufgaben aus dem Business-Kontext an, wie Prädikate, Konverter, Filter und Regel-Bäume.</p>
</div>
<div class="paragraph">
<p>Das nicht-repräsentative Beispiel des Maximums (das natürlich als Lambda viel kompakter ist) soll für eine komplexe Business-Regel stehen, die über mehrere Zeilen mit Hilfe anderer Klassen eine anspruchsvollere Berechnung oder Entscheidung durchführt.</p>
</div>
<div class="paragraph">
<p>static class Max&lt;T extends Number &amp; Comparable&lt;T&gt;&gt; implements BinaryOperator&lt;T&gt; {
    public T operate(T accu, T value) {
        return value.compareTo(accu) &gt; 0 ? value : accu;
    }
}</p>
</div>
<div class="paragraph">
<p>final Optional&lt;Integer&gt; max = Arrays.asList(1, 10, 3, 100, 5).stream().reduce(new Max&lt;&gt;());</p>
</div>
<div class="paragraph">
<p>Leider ist es trotz Erweiterungsmethoden für Interfaces noch nicht möglich, neue Funktionen zu existierenden Klassen hinzuzufügen, das wäre nur über eine entsprechende Subklasse von Stream möglich, die für die jeweilige Anforderung die notwendigen Operationen implementiert und in diesen "iterator()", "wrapSink()" korrekt umsetzt und Meta-Informationen bereitstellt.</p>
</div>
<div class="paragraph">
<p>[libs] - guava, lambdaj, functional-java, commons-collections
[specification] - 	<a href="http://martinfowler.com/apsupp/spec.pdf" class="bare">http://martinfowler.com/apsupp/spec.pdf</a>
[RubeGoldberg] <a href="http://en.wikipedia.org/wiki/Rube_Goldberg_machine" class="bare">http://en.wikipedia.org/wiki/Rube_Goldberg_machine</a>
[java8-streams] <a href="http://blog.jooq.org/2012/04/19/exciting-ideas-in-java-8-streams/" class="bare">http://blog.jooq.org/2012/04/19/exciting-ideas-in-java-8-streams/</a>
[java8-overview] <a href="http://www.techempower.com/blog/2013/03/26/everything-about-java-8/" class="bare">http://www.techempower.com/blog/2013/03/26/everything-about-java-8/</a>
[java8] <a href="http://jdk8.java.net/download.html" class="bare">http://jdk8.java.net/download.html</a>
[java8-javadoc] <a href="http://download.java.net/jdk8/docs/api" class="bare">http://download.java.net/jdk8/docs/api</a>
[EffectiveJava] Joshua Block, Effective Java 2nd Edition
[FunctionalInterface] <a href="http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html" class="bare">http://download.java.net/jdk8/docs/api/java/lang/FunctionalInterface.html</a>
[FunctionPackage] <a href="http://download.java.net/jdk8/docs/api/java/util/function/package-summary.html" class="bare">http://download.java.net/jdk8/docs/api/java/util/function/package-summary.html</a></p>
</div>

</div>


  <div id='wikifoot' class="footnav">
    <div style="text-align:right; float:right" class='lastmod'>Last updated 2013-04-03 22:21:57 CEST</div>
	
      <div style="text-align:center;">
      <a href='http://jexp.de/impressum'>Impressum</a>
    - <a class='urllink' href='http://twitter.com/mesirii'>Twitter</a>
	- <a class='urllink' href='http://github.com/jexp'>GitHub</a>
	- <a class='urllink' href='http://stackoverflow.com/users/story/728812'>StackOverflow</a>
	- <a class='urllink' href='http://linkedin.com/jexpde'>LinkedIn</a>
	
   </div>

</body>
</html>